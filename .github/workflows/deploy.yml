name: Build to OCIR and Deploy to VM

on:
  push:
    branches: [ main ] # รันเมื่อ push ไปที่ main

jobs:
  # --- Job 1: Build และ Push (ทำบน Server GitHub) ---
  build-and-push:
    name: Build and Push to OCIR
    runs-on: ubuntu-latest # ใช้ GitHub-Hosted Runner (x86)

    steps:
    - name: Check out code
      uses: actions/checkout@v4

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to OCIR
      uses: docker/login-action@v3
      with:
        registry: ${{ secrets.OCIR_REGISTRY_URL }}
        username: ${{ secrets.TENANT_NAME }}/${{ secrets.OCIR_USERNAME }}
        password: ${{ secrets.OCIR_TOKEN }}

    - name: Build and push (ARM64)
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        # Build Image สำหรับ ARM64 เท่านั้น (เพราะ VM ปลายทางเป็น ARM)
        platforms: linux/arm64/v8
        push: true
        # Tag Image ด้วย :latest 
        tags: ${{ secrets.OCIR_REGISTRY_URL }}/${{ secrets.OCIR_TENANCY_NAMESPACE }}/secretary-agent:latest

  # --- Job 2: Deploy (สั่ง VM ของคุณให้ Pull Image ใหม่) ---
  deploy-to-prod:
    name: Deploy to Production VM
    needs: build-and-push # รันหลัง Job 1 สำเร็จ
    runs-on: ubuntu-latest # ใช้ GitHub-Hosted Runner

    steps:
    - name: Deploy to arm-server-01
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.DEPLOY_HOST }}       # Public IP ของ VM
        username: ${{ secrets.DEPLOY_USER }}   # opc
        key: ${{ secrets.DEPLOY_KEY }}         # Private Key ที่คุณใส่ใน Secret
        script: |
          # SSH เข้าไปที่ App VM (arm-server-01)
          # ต้องมั่นใจว่า Path นี้ถูกต้อง (ตรงกับที่ clone ไว้ใน Step 3)
          cd ~/Secretary-Agent 
          
          # 1. ดึง Image ใหม่ล่าสุดที่ Build เสร็จจาก OCIR
          docker compose pull
          
          # 2. สั่งรัน (Docker compose จะ restart เฉพาะตัวที่เปลี่ยน)
          docker compose up -d
          
          # 3. (Optional) ลบ Image เก่าๆ ที่ไม่ใช้แล้ว (กัน Storage เต็ม)
          docker image prune -f